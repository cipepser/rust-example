# memory

rustのメモリ表現がどうなっているか。

[RustのSizedとfatポインタ \- 簡潔なQ](https://qnighy.hatenablog.com/entry/2017/03/04/131311)から`as_raw_bytes`を借りる。

```rust
fn as_raw_bytes<'a, T: ?Sized>(x: &'a T) -> &'a [u8] {
    unsafe {
        std::slice::from_raw_parts(
            x as *const T as *const u8,
            std::mem::size_of_val(x))
    }
}
```

### [u8]

まずは`[u8]`（`u8`のスライス）でメモリ表現を見てみる。

これ(`[T]`)はスタック領域に確保されるはず。

`[i32]`を表示してみる。

```rust
let a = [1, 2, 3, 4]; // a: [i32; 4]
println!("{:?}", a);
println!("{:x?}", as_raw_bytes(&a));
```

結果。`0`が多い？

```
[1, 2, 3, 4, 5]
[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0]
```

数字を変えてみる。

```rust
let a = [255, 256, 1023, 1024, 1025];
println!("{:?}", a);
println!("{:x?}", as_raw_bytes(&a));
```

4バイトごと？

```
// 改行は手動
[255, 256, 1023, 1024, 1025]
[ff, 0, 0, 0,
0, 1, 0, 0,
ff, 3, 0, 0,
 0, 4, 0, 0,
 1, 4, 0, 0]
```

`0d255` = `0x00ff`
`0d256` = `0x0100`
`0d1023` = `0x03ff`
`0d1024` = `0x0400`
`0d1025` = `0x0401`

```
// 改行は手動
[4096, 4097, 8192, 8193, 16384, 16385, 32768, 32769]
[0, 10, 0, 0,
 1, 10, 0, 0,
 0, 20, 0, 0,
 1, 20, 0, 0,
 0, 40, 0, 0,
 1, 40, 0, 0,
 0, 80, 0, 0,
 1, 80, 0, 0]
```

```
// 改行、スペースは手動
[32768, 65536, 131072, 262144]
[0, 80, 0, 0,
 0,  0, 1, 0,
 0,  0, 2, 0,
 0,  0, 4, 0]
```

これまでの結果を見てわかるようにリトルエンディアンで表現されている。
`as_raw_bytes`の返り値の型は`[u8]`なので、

```
[0, 4, 0, 0,
 1, 4, 0, 0]
```

は

```
[00, 04, 00, 00,
 01, 04, 00, 00]
```

であることに注意。

これをリトルエンディアンで読めば、

`0x00000400` = `0d1024`
`0x00000401` = `0d1025`

となる。

またちゃんとスタック領域に確保もされていた。

### Vec<u8>


### str


### &str


### String


## References
- [Rustのvtableの内部構造 \- 簡潔なQ](https://qnighy.hatenablog.com/entry/2017/03/18/070000)
- [RustのSizedとfatポインタ \- 簡潔なQ](https://qnighy.hatenablog.com/entry/2017/03/04/131311)